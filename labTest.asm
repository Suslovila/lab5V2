; Директива SECTION используется для определения секций в объектном файле.
; Секция .data обычно содержит инициализированные данные.
SECTION .data
    ; align 8: выравнивает следующие данные по 8-байтовой границе.
    ; Это может быть важно для производительности при доступе к этим данным, особенно для чисел с плавающей точкой.
    align 8
    ; dq (Define Quadword) определяет 8-байтовое значение (double precision floating point).
    three_double: dq 3.0             ; Константа 3.0 для деления при вычислении среднего значения.
    one_double: dq 1.0               ; Константа 1.0 для вычисления (numberOfShades - 1.0).
    const_255_double: dq 255.0       ; Константа 255.0 для формулы ConversionFactor и для ограничения (clamping).
    const_0_5_double: dq 0.5         ; Константа 0.5 для округления по формуле Gray = Integer(Avg/CF + 0.5)*CF.
    zero_double: dq 0.0              ; Константа 0.0 для ограничения минимального значения серого.

    gray_red_factor: dq 0.299              ; Константа 0.0 для ограничения минимального значения серого.
    gray_green_factor: dq 0.587              ; Константа 0.0 для ограничения минимального значения серого.
    gray_blue_factor: dq 0.114              ; Константа 0.0 для ограничения минимального значения серого.

; Секция .text обычно содержит исполняемый код (инструкции).
SECTION .text
    ; global process_image_asm: делает метку process_image_asm видимой для других объектных файлов (например, для main.o),
    ; чтобы компоновщик мог связать вызов этой функции из C-кода с ее реализацией здесь.
    global process_image_asm

; Начало нашей ассемблерной функции.
process_image_asm:
    ; Соглашение о вызовах System V AMD64 ABI (используется в Linux x86-64):
    ; Первый аргумент (imageData) передается в регистре RDI.
    ; Второй аргумент (width) передается в регистре RSI.
    ; Третий аргумент (height) передается в регистре RDX.
    ; Четвертый аргумент (*components) передается в регистре RCX.
    ; Пятый аргумент (numberOfShades) передается в регистре R8.
    ; (Для целочисленных аргументов типа int, фактически используются их 32-битные части: ESI, EDX, R8D).

    ; Пролог функции: сохранение регистров, которые функция обязана сохранить (callee-saved registers).
    ; Если наша функция изменяет значения в регистрах RBX, RBP, R12, R13, R14, R15,
    ; она должна сначала сохранить их исходные значения в стеке, а перед выходом (ret) - восстановить.
    push rbp          ; Сохраняем старое значение RBP (базовый указатель стека) в стек.
    mov rbp, rsp      ; Устанавливаем RBP на текущую вершину стека (RSP). Это стандартная практика для создания стекового фрейма.
    push rbx          ; Сохраняем RBX, так как мы будем его использовать (для компоненты G).
    push r12          ; Сохраняем R12, так как мы будем его использовать (для счетчика ширины).
    push r13          ; Сохраняем R13, так как мы будем его использовать (для компоненты B).
    ; R14, R15 мы не используем, поэтому их сохранять не нужно.

    mov edx, esi
    mov r8d, edx
    mov ecx, edi

    ; Проверка корректности входных параметров.
    test rdi, rdi       ; Проверяем, не равен ли imageData (в RDI) нулю (NULL). test выполняет побитовое И, устанавливает флаги.
    jz .cleanup_and_exit_invalid ; Если результат test равен нулю (флаг ZF=1), значит RDI был 0, переходим к метке выхода с ошибкой.

    cmp esi, 0          ; Сравниваем width (в ESI, 32-битная часть RSI) с нулем.
    jle .cleanup_and_exit_invalid ; Если width <= 0 (Jump if Less or Equal), переходим к выходу с ошибкой.

    cmp edx, 0          ; Сравниваем height (в EDX, 32-битная часть RDX) с нулем.
    jle .cleanup_and_exit_invalid ; Если height <= 0, переходим к выходу с ошибкой.

;    cmp r8d, 2          ; Сравниваем numberOfShades (в R8D, 32-битная часть R8) с 2.
;    jl .cleanup_and_exit_invalid  ; Если numberOfShades < 2 (Jump if Less), переходим к выходу с ошибкой.
    ; Проверку значения *components (что оно равно 3) мы здесь не делаем, полагаясь на проверку в C-коде перед вызовом.

    ; --- Начало вычислений ---

    ; Преобразуем numberOfShades (целое число из R8D) в число с плавающей точкой двойной точности (double).
    pxor xmm0, xmm0      ; Очищаем регистр XMM0 (устанавливаем в 0). XMM-регистры используются для операций с плавающей точкой (SSE/AVX).
    cvtsi2sd xmm0, r8d   ; Convert Scalar Integer to Scalar Double: xmm0 = (double)numberOfShades.

    ; Вычисляем ConversionFactor = 255.0 / (numberOfShades - 1.0)
    ; Сначала (numberOfShades - 1.0):
    movsd xmm1, [rel one_double]     ; Загружаем 1.0 из секции .data в XMM1. [rel ...] - RIP-относительная адресация.
    subsd xmm0, xmm1                 ; xmm0 = xmm0 - xmm1, то есть xmm0 = (double)numberOfShades - 1.0.

    ; Теперь 255.0 / (результат выше):
    movsd xmm1, [rel const_255_double] ; Загружаем 255.0 в XMM1.
    divsd xmm1, xmm0                 ; xmm1 = xmm1 / xmm0. Теперь XMM1 содержит ConversionFactor.

    ; Указатели для работы с данными изображения.
    mov r9, rdi                      ; r9 будет указателем на текущий исходный пиксель (src_pixel_ptr), начинаем с imageData.
    mov r10, rdi                     ; r10 будет указателем на текущий пиксель назначения (dst_pixel_ptr), также начинаем с imageData.

    ; Внешний цикл по высоте изображения (y).
    mov r11d, edx                    ; Загружаем height (из EDX) в R11D (32-битная часть R11) как счетчик для внешнего цикла.
.outer_loop_start:                   ; Метка начала внешнего цикла.
    test r11d, r11d                  ; Проверяем, не дошли ли мы до конца (счетчик y равен 0).
    jz .loops_done                   ; Если равен 0, переходим к завершению циклов.

    ; Внутренний цикл по ширине изображения (x).
    mov r12d, esi                    ; Загружаем width (из ESI) в R12D (32-битная часть R12) как счетчик для внутреннего цикла.
.inner_loop_start:                   ; Метка начала внутреннего цикла.
    test r12d, r12d                  ; Проверяем, не дошли ли мы до конца строки (счетчик x равен 0).
    jz .inner_loop_done              ; Если равен 0, переходим к завершению внутреннего цикла.

    ; Загружаем компоненты R, G, B текущего пикселя.
    ; movzx (Move with Zero Extend) копирует байт и расширяет его нулями до размера регистра назначения (32 бита для EAX/EBX/R13D).
    movzx eax, byte [r9]             ; eax = значение байта по адресу в r9 (компонента R).
    movzx ebx, byte [r9+1]           ; ebx = значение байта по адресу (r9+1) (компонента G).
    movzx r13d, byte [r9+2]          ; r13d = значение байта по адресу (r9+2) (компонента B).

    ; Преобразуем целочисленные R, G, B в числа с плавающей точкой (double).
    pxor xmm2, xmm2                  ; Очищаем XMM2.
    pxor xmm3, xmm3                  ; Очищаем XMM3.
    pxor xmm4, xmm4                  ; Очищаем XMM4.
    cvtsi2sd xmm2, eax               ; xmm2 = (double)R.
    cvtsi2sd xmm3, ebx               ; xmm3 = (double)G.
    cvtsi2sd xmm4, r13d              ; xmm4 = (double)B.

    ; Вычисляем AverageValue = (R + G + B) / 3.0
    addsd xmm2, xmm3                 ; xmm2 = R + G.
    addsd xmm2, xmm4                 ; xmm2 = (R + G) + B.
    divsd xmm2, [rel three_double]   ; xmm2 = (R + G + B) / 3.0. Теперь XMM2 содержит AverageValue.

    ; Вычисляем Temp = AverageValue / ConversionFactor
    ; XMM1 все еще содержит ConversionFactor.
    divsd xmm2, xmm1                 ; xmm2 = AverageValue / ConversionFactor.

    ; Temp = Temp + 0.5 (для последующего округления)
    addsd xmm2, [rel const_0_5_double] ; xmm2 = (AverageValue / ConversionFactor) + 0.5.

    ; Округляем результат до ближайшего целого.
    ; roundsd - инструкция SSE4.1. Третий операнд (0x00) задает режим округления "к ближайшему".
    roundsd xmm2, xmm2, 0x00         ; xmm2 = round( (AverageValue / ConversionFactor) + 0.5 ).

    ; Gray_double = ОкругленноеЗначение * ConversionFactor
    mulsd xmm2, xmm1                 ; xmm2 = ОкругленноеЗначение * ConversionFactor. Теперь XMM2 содержит значение серого как double.

    ; Ограничиваем (clamping) значение Gray_double диапазоном 0.0 - 255.0.
    movsd xmm5, [rel zero_double]    ; Загружаем 0.0 в XMM5.
    maxsd xmm2, xmm5                 ; xmm2 = max(xmm2, 0.0). Если xmm2 было < 0, станет 0.
    movsd xmm5, [rel const_255_double] ; Загружаем 255.0 в XMM5.
    minsd xmm2, xmm5                 ; xmm2 = min(xmm2, 255.0). Если xmm2 было > 255, станет 255.

    ; Преобразуем значение серого (double из XMM2) обратно в целое число (для записи как байт).
    ; cvttsd2si (Convert with Truncation Scalar Double-precision floating-point value to Signed Integer).
    ; Усечение здесь безопасно, так как мы уже ограничили значение диапазоном 0-255.
    cvttsd2si eax, xmm2              ; eax = (int)Gray_double.

    ; Сохраняем младший байт из EAX (который содержит значение серого) по адресу назначения.
    mov byte [r10], al               ; al - это младший байт регистра EAX.

    ; Перемещаем указатели на следующие пиксели.
    add r9, 3                        ; src_pixel_ptr += 3 (переходим к следующему RGB пикселю).
    add r10, 1                       ; dst_pixel_ptr += 1 (переходим к следующему месту для Gray пикселя).

    dec r12d                         ; Уменьшаем счетчик внутреннего цикла (x--).
    jmp .inner_loop_start            ; Переходим к началу внутреннего цикла.
.inner_loop_done:                    ; Метка завершения внутреннего цикла (когда обработали всю строку).

    dec r11d                         ; Уменьшаем счетчик внешнего цикла (y--).
    jmp .outer_loop_start            ; Переходим к началу внешнего цикла.
.loops_done:                         ; Метка завершения обоих циклов.

    ; Обновляем значение по указателю components (который находится в RCX) на 1.
    ; Это означает, что изображение теперь однокомпонентное (оттенки серого).
;    mov dword [rcx], 1               ; Записываем 1 (как 32-битное dword) по адресу в RCX.

; Метка для "чистого" выхода из функции, используется как для нормального завершения, так и при ошибке параметров.
.cleanup_and_exit:
    ; Эпилог функции: восстановление сохраненных регистров в обратном порядке.
    pop r13                          ; Восстанавливаем R13 из стека.
    pop r12                          ; Восстанавливаем R12 из стека.
    pop rbx                          ; Восстанавливаем RBX из стека.
    pop rbp                          ; Восстанавливаем RBP из стека.
    ret                              ; Возврат из функции (к вызывающему коду в main.c).

; Метка, куда мы переходим, если начальные параметры были неверны.
.cleanup_and_exit_invalid:
    ; Здесь мы не делаем ничего особенного, кроме как переходим к общему эпилогу,
    ; чтобы корректно восстановить стек и регистры перед выходом.
    ; Если бы функция возвращала код ошибки, мы бы установили его в RAX здесь.
    jmp .cleanup_and_exit